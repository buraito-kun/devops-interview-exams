# Application Security Vulnerabilities

This document outlines common application security vulnerabilities with examples that candidates should be able to identify and fix during the exam.

## 1. OWASP Top 10 Vulnerabilities

### SQL Injection

**Vulnerable Python Code:**

```python
@app.route('/user/<username>')
def user_profile(username):
    query = f"SELECT * FROM users WHERE username = '{username}'"
    cursor.execute(query)
    user = cursor.fetchone()
    return render_template('profile.html', user=user)
```

**Fixed Code:**

```python
@app.route('/user/<username>')
def user_profile(username):
    query = "SELECT * FROM users WHERE username = %s"
    cursor.execute(query, (username,))
    user = cursor.fetchone()
    return render_template('profile.html', user=user)
```

### Cross-Site Scripting (XSS)

**Vulnerable JavaScript Code:**

```javascript
function displayUserInput() {
  const userInput = new URLSearchParams(window.location.search).get("message");
  document.getElementById("message").innerHTML = userInput;
}
```

**Fixed Code:**

```javascript
function displayUserInput() {
  const userInput = new URLSearchParams(window.location.search).get("message");
  const escapeHTML = (str) => {
    return str.replace(
      /[&<>'"]/g,
      (tag) =>
        ({
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          "'": "&#39;",
          '"': "&quot;",
        }[tag])
    );
  };
  document.getElementById("message").textContent = escapeHTML(userInput);
}
```

### Broken Authentication

**Vulnerable Python Code:**

```python
@app.route('/login', methods=['POST'])
def login():
    username = request.form['username']
    password = request.form['password']

    query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
    cursor.execute(query)
    user = cursor.fetchone()

    if user:
        session['user_id'] = user['id']
        return redirect('/dashboard')
    else:
        return render_template('login.html', error='Invalid credentials')
```

**Fixed Code:**

```python
@app.route('/login', methods=['POST'])
def login():
    username = request.form['username']
    password = request.form['password']

    query = "SELECT * FROM users WHERE username = %s"
    cursor.execute(query, (username,))
    user = cursor.fetchone()

    if user and check_password_hash(user['password_hash'], password):
        session['user_id'] = user['id']
        session.regenerate() # Regenerate session to prevent session fixation
        return redirect('/dashboard')
    else:
        # Add delay to prevent timing attacks
        time.sleep(random.uniform(0.1, 0.3))
        return render_template('login.html', error='Invalid credentials')
```

### Insecure Deserialization

**Vulnerable Python Code:**

```python
@app.route('/api/load_data', methods=['POST'])
def load_data():
    serialized_data = request.form['data']
    data = pickle.loads(base64.b64decode(serialized_data))
    return jsonify(data)
```

**Fixed Code:**

```python
@app.route('/api/load_data', methods=['POST'])
def load_data():
    serialized_data = request.form['data']
    try:
        # Use JSON instead of pickle for deserialization
        data = json.loads(serialized_data)
        # Validate data structure
        if not isinstance(data, dict):
            raise ValueError("Invalid data format")
        return jsonify(data)
    except (json.JSONDecodeError, ValueError) as e:
        return jsonify({"error": "Invalid data format"}), 400
```

### XML External Entities (XXE)

**Vulnerable Python Code:**

```python
@app.route('/api/parse_xml', methods=['POST'])
def parse_xml():
    xml_data = request.data
    root = ET.fromstring(xml_data)
    return jsonify({"result": "XML parsed successfully"})
```

**Fixed Code:**

```python
@app.route('/api/parse_xml', methods=['POST'])
def parse_xml():
    xml_data = request.data

    # Create a safe parser that doesn't resolve external entities
    parser = ET.XMLParser(resolve_entities=False)
    try:
        root = ET.fromstring(xml_data, parser=parser)
        return jsonify({"result": "XML parsed successfully"})
    except ET.ParseError:
        return jsonify({"error": "Invalid XML data"}), 400
```

## 2. Security Misconfigurations

### Insecure CORS Configuration

**Vulnerable Configuration:**

```python
@app.after_request
def add_cors_headers(response):
    response.headers['Access-Control-Allow-Origin'] = '*'
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type,Authorization'
    response.headers['Access-Control-Allow-Methods'] = 'GET,POST,PUT,DELETE,OPTIONS'
    response.headers['Access-Control-Allow-Credentials'] = 'true'
    return response
```

**Fixed Configuration:**

```python
@app.after_request
def add_cors_headers(response):
    origin = request.headers.get('Origin')
    if origin in ['https://example.com', 'https://api.example.com']:
        response.headers['Access-Control-Allow-Origin'] = origin
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type,Authorization'
        response.headers['Access-Control-Allow-Methods'] = 'GET,POST,PUT,DELETE,OPTIONS'
        response.headers['Access-Control-Allow-Credentials'] = 'true'
    return response
```

### Sensitive Information in Error Messages

**Vulnerable Code:**

```python
@app.errorhandler(Exception)
def handle_error(e):
    return jsonify({"error": str(e), "stack_trace": traceback.format_exc()}), 500
```

**Fixed Code:**

```python
@app.errorhandler(Exception)
def handle_error(e):
    # Log the full error for debugging
    app.logger.error(f"Unhandled exception: {str(e)}")
    app.logger.error(traceback.format_exc())

    # Return generic error message to user
    return jsonify({"error": "An internal server error occurred"}), 500
```

## 3. API Security

### Missing Rate Limiting

**Vulnerable Code (No Rate Limiting):**

```python
@app.route('/api/login', methods=['POST'])
def api_login():
    username = request.json.get('username')
    password = request.json.get('password')

    # Authenticate user
    user = authenticate(username, password)
    if user:
        token = create_jwt_token(user)
        return jsonify({"token": token})
    else:
        return jsonify({"error": "Invalid credentials"}), 401
```

**Fixed Code (With Rate Limiting):**

```python
limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

@app.route('/api/login', methods=['POST'])
@limiter.limit("5 per minute")
def api_login():
    username = request.json.get('username')
    password = request.json.get('password')

    # Authenticate user
    user = authenticate(username, password)
    if user:
        token = create_jwt_token(user)
        return jsonify({"token": token})
    else:
        return jsonify({"error": "Invalid credentials"}), 401
```

### Insecure Direct Object References (IDOR)

**Vulnerable Code:**

```python
@app.route('/api/documents/<doc_id>', methods=['GET'])
@jwt_required
def get_document(doc_id):
    query = f"SELECT * FROM documents WHERE id = {doc_id}"
    cursor.execute(query)
    document = cursor.fetchone()

    return jsonify(document)
```

**Fixed Code:**

```python
@app.route('/api/documents/<doc_id>', methods=['GET'])
@jwt_required
def get_document(doc_id):
    # Get current user ID from JWT token
    current_user_id = get_jwt_identity()

    # Use parameterized query and check ownership
    query = "SELECT * FROM documents WHERE id = %s AND user_id = %s"
    cursor.execute(query, (doc_id, current_user_id))
    document = cursor.fetchone()

    if not document:
        return jsonify({"error": "Document not found or access denied"}), 404

    return jsonify(document)
```

## 4. Secure Coding Practices

### Proper Password Storage

**Vulnerable Code:**

```python
def register_user(username, password):
    # Store plaintext password (VERY BAD)
    query = "INSERT INTO users (username, password) VALUES (%s, %s)"
    cursor.execute(query, (username, password))
    conn.commit()
```

**Fixed Code:**

```python
def register_user(username, password):
    # Generate a strong salt and hash the password
    password_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(rounds=12))

    # Store the hashed password
    query = "INSERT INTO users (username, password_hash) VALUES (%s, %s)"
    cursor.execute(query, (username, password_hash))
    conn.commit()
```

### Secure File Uploads

**Vulnerable Code:**

```python
@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' in request.files:
        file = request.files['file']
        if file.filename != '':
            filename = file.filename
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
            return jsonify({"success": True, "filename": filename})
    return jsonify({"error": "No file provided"}), 400
```

**Fixed Code:**

```python
import uuid
import imghdr

def validate_image(stream):
    header = stream.read(512)
    stream.seek(0)
    format = imghdr.what(None, header)
    if not format:
        return None
    return '.' + (format if format != 'jpeg' else 'jpg')

@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({"error": "No file provided"}), 400

    file = request.files['file']

    if file.filename == '':
        return jsonify({"error": "No file selected"}), 400

    # Validate file type
    file_ext = validate_image(file.stream)
    if not file_ext or file_ext not in ['.jpg', '.png', '.gif']:
        return jsonify({"error": "Invalid image format"}), 400

    # Create a safe filename
    random_filename = str(uuid.uuid4())
    filename = random_filename + file_ext

    # Save the file
    file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))

    # Set proper permissions
    os.chmod(os.path.join(app.config['UPLOAD_FOLDER'], filename), 0o644)

    return jsonify({"success": True, "filename": filename})
```

### Content Security Policy (CSP)

**Vulnerable Headers (No CSP):**

```python
@app.after_request
def add_security_headers(response):
    response.headers['X-Content-Type-Options'] = 'nosniff'
    return response
```

**Fixed Headers (With CSP):**

```python
@app.after_request
def add_security_headers(response):
    response.headers['Content-Security-Policy'] = "default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self'; font-src 'self'; connect-src 'self'"
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['X-Frame-Options'] = 'DENY'
    response.headers['X-XSS-Protection'] = '1; mode=block'
    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
    response.headers['Referrer-Policy'] = 'no-referrer-when-downgrade'
    response.headers['Permissions-Policy'] = 'camera=(), microphone=(), geolocation=()'
    return response
```

## 5. Dependency Management

### Vulnerable Code (No Version Pinning):

```
# requirements.txt
flask
sqlalchemy
requests
```

**Fixed Code (With Version Pinning):**

```
# requirements.txt
flask==2.0.1
sqlalchemy==1.4.23
requests==2.26.0
```

### Secure Dependencies Check

```python
# security_check.py
import subprocess
import sys

def check_dependencies():
    print("Checking for vulnerable dependencies...")
    result = subprocess.run(
        ["safety", "check", "--file=requirements.txt", "--json"],
        capture_output=True,
        text=True
    )

    if result.returncode != 0:
        print("Vulnerable dependencies found:")
        print(result.stdout)
        sys.exit(1)
    else:
        print("No vulnerable dependencies found!")

if __name__ == "__main__":
    check_dependencies()
```

## Resources for Application Security Testing

- OWASP ZAP for dynamic application security testing
- Bandit for Python static code analysis
- Safety for Python dependency scanning
- ESLint security plugins for JavaScript code
- SonarQube for comprehensive code quality and security analysis
